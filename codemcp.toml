project_prompt = '''

## Code Style Guidelines
- **Imports**: Standard libs first, third-party next, local imports last
- **Formatting**: Black with 4-space indentation, ~88 char line length
- **Variables**: snake_case for variables/functions, SCREAMING_SNAKE_CASE for constants, CamelCase for classes
- **Error handling**: Use try/except with specific exception types, implement retry logic for external APIs
- **Type hints**: Add parameter and return type hints for new functions
- **Keep changes in existing code as minimal as possible and easy to change in the future**
- **Make sure your code follows PEP8 coding standards**
- **Keep code pythonic**

## Environment settings

- **Conda environment**: `codemcp`

## Git guidance
- **Commit guidance**: 
    - Before staging run formatting and linting
- **Commit messages**: 
    - Coincise, informative
    - Use bulletpoints
    - Mention names of files were added or changed
    - Mention names of classes or methods which were added or changed
- **Branch naming**: Name new branches with ticket code in the beginning, for example `NEW-145`, and then short title 4 words max

## Change Approval and Commit Workflow
CodeMCP now includes a multi-step workflow for code changes:

1. Preview Step:
   - EditFile/WriteFile tools operate in preview mode by default
   - A diff of the proposed changes is shown
   - You must explicitly approve or reject each change

2. Approval Step:
   - When user types "APPROVE" (all caps), you must call the ApproveLastChange tool
   - When user types "REJECT" (all caps), you must call the RejectLastChange tool
   - IMPORTANT: Do NOT use UserPrompt for these simple approve/reject messages!
   - IMPORTANT: After approval, changes are only applied to files, NOT committed!

3. Commit Step (Required, Separate User Command):
   - IMPORTANT: This step requires a new, explicit command from the user
   - After approving changes, STOP and wait for user input
   - Only when the user explicitly types a CommitChanges command should you proceed
   - NEVER automatically run the CommitChanges tool after ApproveLastChange
   - The user must manually type "CommitChanges" with a message

4. Key Commands:
   - APPROVE: User types this to approve changes (you call ApproveLastChange tool)
   - REJECT: User types this to reject changes (you call RejectLastChange tool)
   - CommitChanges: (Separate step) Commit applied changes with a message
   - SetCommitPrompt: Enable/disable commit prompting
   - ListPendingChanges: View all pending changes

Example workflow (THREE separate user messages):
```
# 1. Claude proposes a change with a preview
# 2. User reviews and types "APPROVE" 
#    (You call ApproveLastChange, which applies changes to files ONLY)
#    (Then STOP and wait for the next user input - do NOT proceed further!)
# 3. User types "CommitChanges" with a message to commit
#    (Only NOW do you call the CommitChanges tool)
```

CRITICAL: Do not proceed to step 3 automatically. Wait for explicit user input!
NEVER chain ApproveLastChange and CommitChanges together in one response!

- When you are done with your task, run format and lint commands, and then submit
  a PR using the 'ghstack' command.
- We ONLY write end to end tests, do NOT use mocks.
- When you add a new argument to a function in the codebase, evaluate if it
  makes sense for every call site to pass this argument in.  If it makes
  sense, do NOT default the argument and instead fix all call sites to
  explicitly pass this in.  For example, if ALL call sites already need to be
  updated for the new argument, you should definitely make it non-optional.
- When you make a new tool, the prompt goes in system_prompt in
  codecmp/tools/init_project.py
- If an operation may fail, do NOT wrap it with a try-catch block to suppress
  error and do some fallback handling.  Instead, let the exception propagate
  to the top level so we can properly report it.  If you are trying to fix a test
  because an exception is being thrown in this way, reason about what invariant
  is being violated that is causing the exception to be thrown.
- If you are trying to fix a test because an assert has failed, DO NOT remove
  the assert. Instead, try to reason about what bug could be causing the
  invariant to be violated. If you can't figure it out, ask the user to help
  and halt.
- End-to-end tests which call into codemcp function go in e2e/; unit tests for
  purely functional code go in tests/
'''

[commands]
format = ["./run_format.sh"]
lint = ["./run_lint.sh"]
ghstack = ["uv", "tool", "run", "ghstack"]
typecheck = ["./run_typecheck.sh"]
git = ["/usr/bin/git"]
[commands.test]
command = ["./run_test.sh"]
doc = "Accepts a pytest-style test selector as an argument to run a specific test."
[commands.accept]
command = ["env", "EXPECTTEST_ACCEPT=1", "./run_test.sh"]
doc = "Updates expecttest failing tests with their new values, akin to running with EXPECTTEST_ACCEPT=1. Accepts a pytest-style test selector as an argument to run a specific test."